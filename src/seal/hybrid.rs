//! High-level API for hybrid encryption.
//!
//! This module provides a unified and user-friendly interface for hybrid encryption,
//! combining asymmetric (public-key) and symmetric cryptography to offer scalable
//! and secure data protection. It is the recommended entry point for most users.
//!
//! ## Workflow
//!
//! The typical hybrid encryption workflow involves two main components:
//! 1.  **Key Encapsulation Mechanism (KEM)**: An asymmetric algorithm (e.g., RSA, Kyber)
//!     used by the sender to securely transfer a randomly generated symmetric key
//!     to the recipient using their public key. This part is computationally
//!     expensive and is only used for the key exchange, not for the bulk data.
//! 2.  **Data Encapsulation Mechanism (DEM)**: A symmetric algorithm (e.g., AES-GCM, XChaCha20-Poly1305)
//!     that uses the randomly generated key (from the KEM step) to encrypt the
//!     actual plaintext data. This part is very fast and suitable for large amounts of data.
//!
//! This library abstracts away the complexities of this process, providing a
//! simple, fluent API.
//!
//! ## Execution Modes
//!
//! The API supports multiple execution modes to cater to different use cases:
//! - **In-Memory (Ordinary)**: The entire encryption/decryption process happens in memory.
//!   Suitable for small to medium-sized data.
//!   - Encrypt: `to_vec()`
//!   - Decrypt: `slice()` -> `with_key()`
//! - **In-Memory (Parallel)**: A parallelized version of the in-memory mode, offering
//!   better performance for multi-core systems, especially for larger data chunks
//!   that still fit in memory.
//!   - Encrypt: `to_vec_parallel()`
//!   - Decrypt: `slice_parallel()` -> `with_key()`
//! - **Streaming**: For very large files or data streams that should not be fully
//!   loaded into memory. This mode processes data in chunks.
//!   - Encrypt: `into_writer()`
//!   - Decrypt: `reader()` -> `with_key()`
//! - **Asynchronous Streaming**: A non-blocking version of the streaming mode,
//!   designed for use with async runtimes like Tokio.
//!   - Encrypt: `into_async_writer()`
//!   - Decrypt: `async_reader()` -> `with_key()`
//!
//! ## Advanced Features
//!
//! The `HybridEncryptionOptions` struct provides access to advanced features:
//! - **Associated Data (AAD)**: Authenticate contextual metadata alongside the ciphertext.
//! - **Digital Signatures**: Sign the encryption header to prove the sender's identity.
//! - **Key Derivation (KDF/XOF)**: Instead of a random DEM key, derive it from the
//!   shared secret generated by the KEM. This is useful for protocol compatibility
//!   and specific security requirements.
//!
//! # Example
//!
//! ```no_run
//! use seal_crypto::schemes::{
//!     asymmetric::traditional::rsa::Rsa2048,
//!     hash::Sha256,
//!     symmetric::aes_gcm::Aes256Gcm,
//! };
//! use seal_flow::prelude::*;
//!
//! // 1. Define algorithms
//! type Kem = Rsa2048<Sha256>;
//! type Dek = Aes256Gcm;
//!
//! // 2. Setup keys
//! let (pk, sk) = Kem::generate_keypair().unwrap();
//! let pk_wrapped = AsymmetricPublicKey::new(pk.to_bytes());
//! let sk_wrapped = AsymmetricPrivateKey::new(sk.to_bytes());
//! let kek_id = "my-key-id".to_string();
//!
//! // 3. Encrypt
//! let seal = HybridSeal::new();
//! let plaintext = b"secret message";
//! let ciphertext = seal.encrypt::<Dek>(pk_wrapped, kek_id)
//!     .to_vec::<Kem>(plaintext)
//!     .unwrap();
//!
//! // 4. Decrypt
//! let pending = seal.decrypt().slice(&ciphertext).unwrap();
//! let decrypted = pending.with_key(sk_wrapped).unwrap();
//!
//! assert_eq!(plaintext, &decrypted[..]);
//! ```
use crate::algorithms::traits::SymmetricAlgorithm;
use crate::common::algorithms::{KdfAlgorithm, SignatureAlgorithm, XofAlgorithm};
use crate::keys::{AsymmetricPrivateKey, AsymmetricPublicKey};
use decryptor::HybridDecryptorBuilder;
use encryptor::HybridEncryptor;
use std::marker::PhantomData;
use suites::PqcEncryptor;

pub mod decryptor;
pub mod encryptor;
pub mod suites;

/// Configuration for a digital signature to be applied during encryption.
///
/// This allows the sender to prove their identity by signing the encryption
/// metadata (header). The recipient can then verify this signature using the
/// sender's public key.
pub struct SignerOptions {
    /// The private key used for signing.
    pub key: AsymmetricPrivateKey,
    /// The ID of the signing key. This ID is stored in the header and is used by
    /// the recipient to look up the corresponding public key for verification.
    pub key_id: String,
    /// The signature algorithm to use.
    pub algorithm: SignatureAlgorithm,
}

/// Options for using a Key Derivation Function (KDF) to generate the Data Encryption Key (DEK).
///
/// Normally, a fresh, random DEK is generated for each encryption.
/// Using a KDF allows you to derive a deterministic DEK from the shared secret
/// produced by the Key Encapsulation Mechanism (KEM). This can be necessary for
/// compatibility with certain cryptographic protocols (e.g., HPKE).
pub struct KdfOptions {
    /// The KDF algorithm to use (e.g., HKDF-SHA256).
    pub algorithm: KdfAlgorithm,
    /// An optional salt value, highly recommended for security.
    pub salt: Option<Vec<u8>>,
    /// Optional context-specific information, used to bind the derived key to a
    /// specific purpose.
    pub info: Option<Vec<u8>>,
    /// The desired length of the derived DEK in bytes. This must match the
    /// key length required by the chosen symmetric algorithm.
    pub output_len: u32,
}

/// Options for using an Extendable-Output Function (XOF) to generate the DEK.
///
/// A XOF is similar to a KDF but can produce an output of arbitrary length.
/// It's a flexible way to derive keys or other security material.
pub struct XofOptions {
    /// The XOF algorithm to use (e.g., SHAKE256).
    pub algorithm: XofAlgorithm,
    /// An optional salt value.
    pub salt: Option<Vec<u8>>,
    /// Optional context-specific information.
    pub info: Option<Vec<u8>>,
    /// The desired length of the derived DEK in bytes.
    pub output_len: u32,
}

/// Enum to select between KDF and XOF for key derivation.
pub enum DerivationOptions {
    /// Use a Key Derivation Function.
    Kdf(KdfOptions),
    /// Use an Extendable-Output Function.
    Xof(XofOptions),
}

/// A builder for configuring advanced options for a hybrid encryption operation.
///
/// This struct uses a builder pattern to let you chain configuration calls.
#[derive(Default)]
pub struct HybridEncryptionOptions {
    pub(crate) aad: Option<Vec<u8>>,
    pub(crate) signer: Option<SignerOptions>,
    pub(crate) derivation: Option<DerivationOptions>,
}

impl HybridEncryptionOptions {
    /// Creates a new, default set of options.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the Associated Data (AAD) for the encryption operation.
    ///
    /// AAD is authenticated along with the ciphertext but is not encrypted.
    /// It's useful for binding the encrypted data to its context (e.g., headers,
    /// version numbers, or identifiers) to prevent semantic or replay attacks.
    /// The same AAD must be provided during decryption for the authentication to succeed.
    pub fn with_aad(mut self, aad: impl Into<Vec<u8>>) -> Self {
        self.aad = Some(aad.into());
        self
    }

    /// Configures the operation to digitally sign the encryption metadata.
    ///
    /// This proves the sender's identity to the recipient. The `key` should be the
    /// sender's private signing key. The `key_id` is included in the header so
    /// the recipient knows which public key to use for verification.
    pub fn with_signer(
        mut self,
        key: AsymmetricPrivateKey,
        key_id: String,
        algorithm: SignatureAlgorithm,
    ) -> Self {
        self.signer = Some(SignerOptions {
            key,
            key_id,
            algorithm,
        });
        self
    }

    /// Configures the operation to use a Key Derivation Function (KDF) to create the DEK.
    ///
    /// Instead of generating a random DEK, it will be derived from the KEM's shared secret.
    ///
    /// # Arguments
    /// * `algorithm`: The KDF algorithm to use.
    /// * `salt`: An optional salt. Highly recommended.
    /// * `info`: Optional context-specific information.
    /// * `output_len`: The desired length of the derived key. Must match the chosen
    ///   symmetric cipher's key length.
    pub fn with_kdf(
        mut self,
        algorithm: KdfAlgorithm,
        salt: Option<Vec<u8>>,
        info: Option<Vec<u8>>,
        output_len: u32,
    ) -> Self {
        self.derivation = Some(DerivationOptions::Kdf(KdfOptions {
            algorithm,
            salt,
            info,
            output_len,
        }));
        self
    }

    /// Configures the operation to use an Extendable-Output Function (XOF) to create the DEK.
    ///
    /// Similar to a KDF, but based on a XOF algorithm like SHAKE256.
    pub fn with_xof(
        mut self,
        algorithm: XofAlgorithm,
        salt: Option<Vec<u8>>,
        info: Option<Vec<u8>>,
        output_len: u32,
    ) -> Self {
        self.derivation = Some(DerivationOptions::Xof(XofOptions {
            algorithm,
            salt,
            info,
            output_len,
        }));
        self
    }
}

/// A factory for creating hybrid encryption and decryption executors.
/// This struct is the main entry point for the high-level hybrid encryption API.
/// It is stateless and can be reused for multiple operations.
#[derive(Default)]
pub struct HybridSeal;

impl HybridSeal {
    /// Creates a new `HybridSeal` factory.
    pub fn new() -> Self {
        Self
    }

    /// Begins a hybrid encryption operation.
    ///
    /// This method sets up the context for encryption. It captures the recipient's
    /// public key (`pk`) and its identifier (`kek_id`). The `kek_id` is stored
    /// in the ciphertext header so the recipient can easily identify which of their
    /// private keys is needed for decryption.
    ///
    /// # Type Parameters
    /// * `S`: The symmetric algorithm (DEK) to be used for bulk data encryption,
    ///   e.g., `Aes256Gcm`.
    ///
    /// This returns a `HybridEncryptor` context object. You can then chain calls
    /// to configure advanced options or call an execution method (like `.to_vec()`)
    /// to perform the encryption.
    pub fn encrypt<S>(&self, pk: AsymmetricPublicKey, kek_id: String) -> HybridEncryptor<S>
    where
        S: SymmetricAlgorithm,
    {
        HybridEncryptor {
            pk,
            kek_id,
            aad: None,
            signer: None,
            derivation_config: None,
            _phantom: PhantomData,
        }
    }

    /// Begins a hybrid encryption operation using a recommended Post-Quantum Cryptography (PQC) suite.
    ///
    /// This provides a simplified API that uses `Kyber768` for key encapsulation and
    /// `Aes256Gcm` for data encapsulation, a combination recommended for post-quantum security.
    pub fn encrypt_pqc_suite(&self, pk: AsymmetricPublicKey, kek_id: String) -> PqcEncryptor {
        PqcEncryptor::new(pk, kek_id)
    }

    /// Begins a hybrid decryption operation.
    ///
    /// This returns a `HybridDecryptorBuilder`. You can then use this builder to
    /// specify the source of the ciphertext (e.g., `.slice()` or `.reader()`).
    ///
    /// The builder can also be configured with a `KeyProvider` to automate the
    /// key lookup process during decryption.
    pub fn decrypt(&self) -> HybridDecryptorBuilder<'_> {
        HybridDecryptorBuilder::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::keys::{AsymmetricPrivateKey, SignaturePublicKey};
    use crate::Error;
    use seal_crypto::prelude::*;
    use seal_crypto::schemes::asymmetric::post_quantum::dilithium::Dilithium2;
    use seal_crypto::schemes::asymmetric::traditional::ecc::Ed25519;
    use seal_crypto::schemes::kdf::hkdf::HkdfSha256;
    use seal_crypto::schemes::xof::shake::Shake256;
    use seal_crypto::schemes::{
        asymmetric::traditional::rsa::Rsa2048, hash::Sha256, symmetric::aes_gcm::Aes256Gcm,
    };
    use std::collections::HashMap;
    use std::io::{Cursor, Read, Write};

    #[cfg(feature = "async")]
    const TEST_KEK_ID: &str = "test-kek";

    fn get_test_data() -> &'static [u8] {
        b"This is a reasonably long test message to ensure that we cross chunk boundaries."
    }

    type TestKem = Rsa2048<Sha256>;
    type TestDek = Aes256Gcm;
    type TestSigner = Dilithium2;

    #[test]
    fn test_generic_options_roundtrip() -> crate::Result<()> {
        // 1. Setup keys
        let (enc_pk, enc_sk) = TestKem::generate_keypair()?;
        let enc_pk_wrapped = AsymmetricPublicKey::new(enc_pk.to_bytes());
        let (sig_pk, sig_sk) = Ed25519::generate_keypair()?;
        let sig_pk_wrapped = SignaturePublicKey::new(sig_pk.to_bytes());
        let sig_sk_wrapped = AsymmetricPrivateKey::new(sig_sk.to_bytes());

        // 2. Setup data and options
        let plaintext = get_test_data();
        let aad = b"generic-options-aad";
        let kek_id = "test-generic-options-kek-id".to_string();
        let signer_key_id = "test-generic-options-signer-id".to_string();
        let seal = HybridSeal::new();

        let options = HybridEncryptionOptions::new()
            .with_aad(aad)
            .with_signer(
                sig_sk_wrapped,
                signer_key_id.clone(),
                crate::common::algorithms::SignatureAlgorithm::Ed25519,
            );

        // 3. Encrypt using generic encryptor with options
        let encrypted = seal
            .encrypt::<TestDek>(enc_pk_wrapped, kek_id.clone())
            .with_options(options)
            .to_vec::<TestKem>(plaintext)?;

        // 4. Decrypt and verify
        let mut verifiers = HashMap::new();
        verifiers.insert(signer_key_id.clone(), sig_pk_wrapped);

        let pending = seal.decrypt().slice(&encrypted)?;
        assert_eq!(pending.kek_id(), Some(kek_id.as_str()));

        let retrieved_signer_id = pending
            .signer_key_id()
            .ok_or("missing signer key id")
            .map_err(|e| Error::AsyncTaskError(e.to_string()))?;
        let verification_key = verifiers
            .get(retrieved_signer_id)
            .ok_or("verification key not found")
            .map_err(|e| Error::AsyncTaskError(e.to_string()))?;

        let decrypted = pending
            .with_aad(aad)
            .with_verification_key(verification_key.clone())?
            .with_typed_key::<TestKem, TestDek>(&enc_sk)?;

        assert_eq!(plaintext, decrypted.as_slice());
        Ok(())
    }

    #[test]
    fn test_generic_options_with_kdf_roundtrip() -> crate::Result<()> {
        // 1. Setup keys
        let (enc_pk, enc_sk) = TestKem::generate_keypair()?;
        let enc_pk_wrapped = AsymmetricPublicKey::new(enc_pk.to_bytes());

        // 2. Setup data and options
        let plaintext = get_test_data();
        let salt = b"my-kdf-salt";
        let info = b"my-kdf-info";
        let kek_id = "test-generic-kdf-kek-id".to_string();
        let seal = HybridSeal::new();

        let options = HybridEncryptionOptions::new().with_kdf(
            crate::common::algorithms::KdfAlgorithm::HkdfSha512,
            Some(salt.to_vec()),
            Some(info.to_vec()),
            32,
        );

        // 3. Encrypt using generic encryptor with options
        let encrypted = seal
            .encrypt::<TestDek>(enc_pk_wrapped, kek_id.clone())
            .with_options(options)
            .to_vec::<TestKem>(plaintext)?;

        // 4. Decrypt and verify
        let pending = seal.decrypt().slice(&encrypted)?;
        assert_eq!(pending.kek_id(), Some(kek_id.as_str()));

        let decrypted = pending.with_typed_key::<TestKem, TestDek>(&enc_sk)?;

        assert_eq!(plaintext, decrypted.as_slice());
        Ok(())
    }

    #[test]
    fn test_pqc_suite_with_options_roundtrip() -> crate::Result<()> {
        // 1. Setup keys
        let (enc_pk, enc_sk) = suites::PqcKem::generate_keypair()?;
        let enc_pk_wrapped = AsymmetricPublicKey::new(enc_pk.to_bytes());
        let (sig_pk, sig_sk) = TestSigner::generate_keypair()?;
        let sig_pk_wrapped = SignaturePublicKey::new(sig_pk.to_bytes());
        let sig_sk_wrapped = AsymmetricPrivateKey::new(sig_sk.to_bytes());

        // 2. Setup data and options
        let plaintext = get_test_data();
        let aad = b"pqc-options-aad";
        let kek_id = "test-pqc-options-kek-id".to_string();
        let signer_key_id = "test-pqc-options-signer-id".to_string();
        let seal = HybridSeal::new();

        let options = HybridEncryptionOptions::new()
            .with_aad(aad)
            .with_signer(
                sig_sk_wrapped,
                signer_key_id.clone(),
                crate::common::algorithms::SignatureAlgorithm::Dilithium2,
            );

        // 3. Encrypt using the PQC suite with options
        let encrypted = seal
            .encrypt_pqc_suite(enc_pk_wrapped, kek_id.clone())
            .with_options(options)
            .to_vec(plaintext)?;

        // 4. Decrypt and verify
        let mut verifiers = HashMap::new();
        verifiers.insert(signer_key_id.clone(), sig_pk_wrapped);

        let pending = seal.decrypt().slice(&encrypted)?;
        assert_eq!(pending.kek_id(), Some(kek_id.as_str()));

        // Get the verification key from the verifiers map
        let retrieved_signer_id = pending
            .signer_key_id()
            .ok_or("missing signer key id")
            .map_err(|e| Error::AsyncTaskError(e.to_string()))?;
        let verification_key = verifiers
            .get(retrieved_signer_id)
            .ok_or("verification key not found")
            .map_err(|e| Error::AsyncTaskError(e.to_string()))?;

        let decrypted = pending
            .with_aad(aad)
            .with_verification_key(verification_key.clone())?
            .with_typed_key::<suites::PqcKem, suites::PqcDek>(&enc_sk)?;

        assert_eq!(plaintext, decrypted.as_slice());
        Ok(())
    }

    #[test]
    fn test_pqc_suite_in_memory_roundtrip() -> crate::Result<()> {
        let (pk, sk) = suites::PqcKem::generate_keypair()?;
        let pk_wrapped = AsymmetricPublicKey::new(pk.to_bytes());
        let plaintext = get_test_data();
        let kek_id = "test-pqc-kek-id".to_string();
        let seal = HybridSeal::new();

        // Encrypt using the PQC suite
        let encrypted = seal
            .encrypt_pqc_suite(pk_wrapped, kek_id.clone())
            .to_vec(plaintext)?;

        // Decrypt using the generic decryptor
        let pending = seal.decrypt().slice(&encrypted)?;
        assert_eq!(pending.kek_id(), Some(kek_id.as_str()));
        let decrypted = pending.with_typed_key::<suites::PqcKem, suites::PqcDek>(&sk)?;

        assert_eq!(plaintext, decrypted.as_slice());
        Ok(())
    }

    #[test]
    fn test_in_memory_roundtrip() -> crate::Result<()> {
        let (pk, sk) = TestKem::generate_keypair()?;
        let pk_wrapped = AsymmetricPublicKey::new(pk.to_bytes());
        let plaintext = get_test_data();
        let kek_id = "test-kek-id".to_string();
        let seal = HybridSeal::new();

        let encrypted = seal
            .encrypt::<TestDek>(pk_wrapped, kek_id.clone())
            .to_vec::<TestKem>(plaintext)?;

        let pending = seal.decrypt().slice(&encrypted)?;
        assert_eq!(pending.kek_id(), Some(kek_id.as_str()));
        let decrypted = pending.with_typed_key::<TestKem, TestDek>(&sk)?;

        assert_eq!(plaintext, decrypted.as_slice());
        Ok(())
    }

    #[test]
    fn test_in_memory_parallel_roundtrip() -> crate::Result<()> {
        let (pk, sk) = TestKem::generate_keypair()?;
        let pk_wrapped = AsymmetricPublicKey::new(pk.to_bytes());
        let plaintext = get_test_data();
        let kek_id = "test-kek-id-parallel".to_string();
        let seal = HybridSeal::new();

        let encrypted = seal
            .encrypt::<TestDek>(pk_wrapped, kek_id.clone())
            .to_vec_parallel::<TestKem>(plaintext)?;

        let pending = seal.decrypt().slice_parallel(&encrypted)?;
        assert_eq!(pending.kek_id(), Some(kek_id.as_str()));
        let decrypted = pending.with_typed_key::<TestKem, TestDek>(&sk)?;

        assert_eq!(plaintext, decrypted.as_slice());
        Ok(())
    }

    #[test]
    fn test_streaming_roundtrip() {
        let mut key_store = HashMap::new();
        let (pk, sk) = TestKem::generate_keypair().unwrap();
        let pk_wrapped = AsymmetricPublicKey::new(pk.to_bytes());
        key_store.insert(TEST_KEK_ID.to_string(), sk);

        let plaintext = get_test_data();
        let seal = HybridSeal::new();

        // Encrypt
        let mut encrypted_data = Vec::new();
        let mut encryptor = seal
            .encrypt::<TestDek>(pk_wrapped, TEST_KEK_ID.to_string())
            .into_writer::<TestKem, _>(&mut encrypted_data)
            .unwrap();
        encryptor.write_all(plaintext).unwrap();
        encryptor.finish().unwrap();

        // Decrypt
        let pending = seal.decrypt().reader(Cursor::new(encrypted_data)).unwrap();
        let kek_id = pending.kek_id().unwrap();
        let decryption_key = key_store.get(kek_id).unwrap();
        let mut decryptor = pending
            .with_typed_key::<TestKem, TestDek>(decryption_key)
            .unwrap();

        let mut decrypted_data = Vec::new();
        decryptor.read_to_end(&mut decrypted_data).unwrap();
        assert_eq!(plaintext.to_vec(), decrypted_data);
    }

    #[test]
    fn test_parallel_streaming_roundtrip() -> crate::Result<()> {
        let (pk, sk) = TestKem::generate_keypair()?;
        let pk_wrapped = AsymmetricPublicKey::new(pk.to_bytes());
        let plaintext = get_test_data();
        let kek_id = "test-kek-id-p-streaming".to_string();
        let seal = HybridSeal::new();

        let mut encrypted = Vec::new();
        seal.encrypt::<TestDek>(pk_wrapped, kek_id.clone())
            .pipe_parallel::<TestKem, _, _>(Cursor::new(plaintext), &mut encrypted)?;

        let pending = seal.decrypt().reader_parallel(Cursor::new(&encrypted))?;
        assert_eq!(pending.kek_id(), Some(kek_id.as_str()));

        let mut decrypted = Vec::new();
        pending.with_typed_key_to_writer::<TestKem, TestDek, _>(&sk, &mut decrypted)?;

        assert_eq!(plaintext, decrypted.as_slice());
        Ok(())
    }

    #[test]
    fn test_with_key_bytes_roundtrip() -> crate::Result<()> {
        let (pk, sk) = TestKem::generate_keypair()?;
        let pk_wrapped = AsymmetricPublicKey::new(pk.to_bytes());
        let sk_wrapped = AsymmetricPrivateKey::new(sk.to_bytes());
        let plaintext = get_test_data();
        let kek_id = "test-kek-id-bytes".to_string();
        let seal = HybridSeal::new();

        let encrypted = seal
            .encrypt::<TestDek>(pk_wrapped, kek_id.clone())
            .to_vec::<TestKem>(plaintext)?;

        let pending = seal.decrypt().slice(&encrypted)?;
        assert_eq!(pending.kek_id(), Some(kek_id.as_str()));
        let decrypted = pending.with_key(sk_wrapped)?;

        assert_eq!(plaintext, decrypted.as_slice());
        Ok(())
    }

    #[test]
    fn test_aad_roundtrip() -> crate::Result<()> {
        let (pk, sk) = TestKem::generate_keypair()?;
        let pk_wrapped = AsymmetricPublicKey::new(pk.to_bytes());
        let plaintext = get_test_data();
        let aad = b"test-associated-data-for-hybrid";
        let kek_id = "aad-kek".to_string();
        let seal = HybridSeal::new();

        // Encrypt with AAD
        let encrypted = seal
            .encrypt::<TestDek>(pk_wrapped, kek_id.clone())
            .with_aad(aad)
            .to_vec::<TestKem>(plaintext)?;

        // Decrypt with correct AAD
        let pending = seal.decrypt().slice(&encrypted)?;
        assert_eq!(pending.kek_id(), Some(kek_id.as_str()));
        let decrypted = pending
            .with_aad(aad)
            .with_typed_key::<TestKem, TestDek>(&sk)?;
        assert_eq!(plaintext, decrypted.as_slice());

        // Decrypt with wrong AAD fails
        let pending_fail = seal.decrypt().slice(&encrypted)?;
        let result = pending_fail
            .with_aad(b"wrong-aad")
            .with_typed_key::<TestKem, TestDek>(&sk);
        assert!(result.is_err());

        // Decrypt with no AAD fails
        let pending_fail2 = seal.decrypt().slice(&encrypted)?;
        let result2 = pending_fail2.with_typed_key::<TestKem, TestDek>(&sk);
        assert!(result2.is_err());

        Ok(())
    }

    #[test]
    fn test_signed_aad_tampering_fails() -> crate::Result<()> {
        // 1. Setup keys
        let (enc_pk, enc_sk) = TestKem::generate_keypair()?;
        let enc_pk_wrapped = AsymmetricPublicKey::new(enc_pk.to_bytes());
        let (sig_pk, sig_sk) = TestSigner::generate_keypair()?;
        let sig_sk_wrapped = AsymmetricPrivateKey::new(sig_sk.to_bytes());
        let sig_pk_bytes = sig_pk.to_bytes();

        // 2. Setup verification key
        let signer_key_id = "test-signer-key-mem".to_string();
        let verification_key = SignaturePublicKey::new(sig_pk_bytes);

        let plaintext = get_test_data();
        let aad = b"test-signed-aad-memory";
        let kek_id = "test-signed-aad-kek-mem".to_string();
        let seal = HybridSeal::new();

        // 3. Encrypt with signer and AAD
        let encrypted = seal
            .encrypt::<TestDek>(enc_pk_wrapped, kek_id)
            .with_aad(aad)
            .with_signer::<TestSigner>(sig_sk_wrapped, signer_key_id.clone())
            .to_vec::<TestKem>(plaintext)?;

        // 4. Successful roundtrip with correct verifier and AAD
        let decrypted = seal
            .decrypt()
            .slice(&encrypted)?
            .with_aad(aad)
            .with_verification_key(verification_key.clone())?
            .with_typed_key::<TestKem, TestDek>(&enc_sk)?;
        assert_eq!(decrypted.as_slice(), plaintext);

        // 5. Fails with wrong AAD
        let res = seal
            .decrypt()
            .slice(&encrypted)?
            .with_aad(b"wrong aad")
            .with_verification_key(verification_key.clone())?
            .with_typed_key::<TestKem, TestDek>(&enc_sk);
        assert!(res.is_err(), "Decryption should fail with wrong AAD");
        assert!(matches!(res.err(), Some(Error::Crypto(_))));

        // 6. Fails with no AAD
        let res2 = seal
            .decrypt()
            .slice(&encrypted)?
            .with_verification_key(verification_key)?
            .with_typed_key::<TestKem, TestDek>(&enc_sk);
        assert!(res2.is_err(), "Decryption should fail with no AAD");

        Ok(())
    }

    #[test]
    fn test_kdf_roundtrip_all_modes() -> crate::Result<()> {
        // 1. Setup
        let (pk, sk) = TestKem::generate_keypair()?;
        let pk_wrapped = AsymmetricPublicKey::new(pk.to_bytes());
        let plaintext = get_test_data();
        let aad = b"test-aad-for-kdf-roundtrip";
        let kek_id = "test-kdf-kek-id".to_string();
        let salt = b"kdf-salt";
        let info = b"kdf-info";
        let seal = HybridSeal::new();
        type Kdf = HkdfSha256;

        // 2. Encryption with KDF
        // We also add AAD to ensure it works together with KDF.
        let encrypted = seal
            .encrypt::<TestDek>(pk_wrapped, kek_id.clone())
            .with_aad(aad)
            .with_kdf(
                Kdf::default(),
                Some(salt),
                Some(info),
                <TestDek as SymmetricCipher>::KEY_SIZE as u32,
            )
            .to_vec::<TestKem>(plaintext)?;

        // 3. Decryption tests for all sync modes

        // Mode 1: In-memory (`slice`)
        let decrypted1 = seal
            .decrypt()
            .slice(&encrypted)?
            .with_aad(aad)
            .with_typed_key::<TestKem, TestDek>(&sk)?;
        assert_eq!(
            plaintext,
            decrypted1.as_slice(),
            "In-memory KDF mode failed"
        );

        // Mode 2: In-memory parallel (`slice_parallel`)
        let decrypted2 = seal
            .decrypt()
            .slice_parallel(&encrypted)?
            .with_aad(aad)
            .with_typed_key::<TestKem, TestDek>(&sk)?;
        assert_eq!(
            plaintext,
            decrypted2.as_slice(),
            "In-memory parallel KDF mode failed"
        );

        // Mode 3: Streaming (`reader`)
        let pending3 = seal.decrypt().reader(Cursor::new(encrypted.clone()))?;
        let mut decryptor3 = pending3
            .with_aad(aad)
            .with_typed_key::<TestKem, TestDek>(&sk)?;
        let mut decrypted3 = Vec::new();
        decryptor3.read_to_end(&mut decrypted3)?;
        assert_eq!(
            plaintext,
            decrypted3.as_slice(),
            "Streaming KDF mode failed"
        );

        // Mode 4: Parallel Streaming (`reader_parallel` to writer)
        let mut decrypted4 = Vec::new();
        seal.decrypt()
            .reader_parallel(Cursor::new(&encrypted))?
            .with_aad(aad)
            .with_typed_key_to_writer::<TestKem, TestDek, _>(&sk, &mut decrypted4)?;
        assert_eq!(
            plaintext,
            decrypted4.as_slice(),
            "Parallel streaming KDF mode failed"
        );

        Ok(())
    }

    #[test]
    fn test_xof_roundtrip_all_modes() -> crate::Result<()> {
        // 1. Setup
        let (pk, sk) = TestKem::generate_keypair()?;
        let pk_wrapped = AsymmetricPublicKey::new(pk.to_bytes());
        let plaintext = get_test_data();
        let aad = b"test-aad-for-xof-roundtrip";
        let kek_id = "test-xof-kek-id".to_string();
        let salt = b"xof-salt";
        let info = b"xof-info";
        let seal = HybridSeal::new();
        type Xof = Shake256;

        // 2. Encryption with XOF
        let encrypted = seal
            .encrypt::<TestDek>(pk_wrapped, kek_id.clone())
            .with_aad(aad)
            .with_xof(
                Xof::default(),
                Some(salt),
                Some(info),
                <TestDek as SymmetricCipher>::KEY_SIZE as u32,
            )
            .to_vec::<TestKem>(plaintext)?;

        // 3. Decryption tests for all sync modes

        // Mode 1: In-memory (`slice`)
        let decrypted1 = seal
            .decrypt()
            .slice(&encrypted)?
            .with_aad(aad)
            .with_typed_key::<TestKem, TestDek>(&sk)?;
        assert_eq!(
            plaintext,
            decrypted1.as_slice(),
            "In-memory XOF mode failed"
        );

        // Mode 2: In-memory parallel (`slice_parallel`)
        let decrypted2 = seal
            .decrypt()
            .slice_parallel(&encrypted)?
            .with_aad(aad)
            .with_typed_key::<TestKem, TestDek>(&sk)?;
        assert_eq!(
            plaintext,
            decrypted2.as_slice(),
            "In-memory parallel XOF mode failed"
        );

        // Mode 3: Streaming (`reader`)
        let pending3 = seal.decrypt().reader(Cursor::new(encrypted.clone()))?;
        let mut decryptor3 = pending3
            .with_aad(aad)
            .with_typed_key::<TestKem, TestDek>(&sk)?;
        let mut decrypted3 = Vec::new();
        decryptor3.read_to_end(&mut decrypted3)?;
        assert_eq!(
            plaintext,
            decrypted3.as_slice(),
            "Streaming XOF mode failed"
        );

        // Mode 4: Parallel Streaming (`reader_parallel` to writer)
        let mut decrypted4 = Vec::new();
        seal.decrypt()
            .reader_parallel(Cursor::new(&encrypted))?
            .with_aad(aad)
            .with_typed_key_to_writer::<TestKem, TestDek, _>(&sk, &mut decrypted4)?;
        assert_eq!(
            plaintext,
            decrypted4.as_slice(),
            "Parallel streaming XOF mode failed"
        );

        Ok(())
    }

    #[test]
    fn test_pqc_suite_with_kdf_roundtrip() -> crate::Result<()> {
        // 1. Setup keys
        let (enc_pk, enc_sk) = suites::PqcKem::generate_keypair()?;
        let enc_pk_wrapped = AsymmetricPublicKey::new(enc_pk.to_bytes());

        // 2. Setup data
        let plaintext = get_test_data();
        let salt = b"pqc-kdf-salt";
        let info = b"pqc-kdf-info";
        let kek_id = "test-pqc-kdf-kek-id".to_string();
        let seal = HybridSeal::new();

        // 3. Encrypt using PQC suite with KDF
        let encrypted = seal
            .encrypt_pqc_suite(enc_pk_wrapped, kek_id.clone())
            .with_kdf(
                seal_crypto::schemes::kdf::hkdf::HkdfSha256::default(),
                Some(salt.to_vec()),
                Some(info.to_vec()),
                32,
            )
            .to_vec(plaintext)?;

        // 4. Decrypt and verify
        let pending = seal.decrypt().slice(&encrypted)?;
        assert_eq!(pending.kek_id(), Some(kek_id.as_str()));

        let decrypted = pending.with_typed_key::<suites::PqcKem, suites::PqcDek>(&enc_sk)?;

        assert_eq!(plaintext, decrypted.as_slice());
        Ok(())
    }

    #[cfg(feature = "async")]
    mod async_tests {
        use super::*;
        use tokio::io::{AsyncReadExt, AsyncWriteExt};

        #[tokio::test]
        async fn test_asynchronous_streaming_roundtrip() {
            let mut key_store = HashMap::new();
            let (pk, sk) = TestKem::generate_keypair().unwrap();
            let pk_wrapped = AsymmetricPublicKey::new(pk.to_bytes());
            key_store.insert(TEST_KEK_ID.to_string(), sk.clone());

            let plaintext = get_test_data();
            let seal = HybridSeal::new();

            // Encrypt
            let mut encrypted_data = Vec::new();
            let mut encryptor = seal
                .encrypt::<TestDek>(pk_wrapped, TEST_KEK_ID.to_string())
                .into_async_writer::<TestKem, _>(&mut encrypted_data)
                .await
                .unwrap();
            encryptor.write_all(plaintext).await.unwrap();
            encryptor.shutdown().await.unwrap();

            // Decrypt
            let pending = seal
                .decrypt()
                .async_reader(Cursor::new(&encrypted_data))
                .await
                .unwrap();
            let kek_id = pending.kek_id().unwrap();
            let decryption_key = key_store.get(kek_id).unwrap();
            let mut decryptor = pending
                .with_typed_key::<TestKem, TestDek>((*decryption_key).clone())
                .await
                .unwrap();

            let mut decrypted_data = Vec::new();
            decryptor.read_to_end(&mut decrypted_data).await.unwrap();
            assert_eq!(plaintext.to_vec(), decrypted_data);
        }

        #[tokio::test]
        async fn test_kdf_async_roundtrip() -> crate::Result<()> {
            // 1. Setup
            let (pk, sk) = TestKem::generate_keypair()?;
            let pk_wrapped = AsymmetricPublicKey::new(pk.to_bytes());
            let plaintext = get_test_data();
            let aad = b"test-aad-for-kdf-async-roundtrip";
            let kek_id = "test-kdf-kek-id-async".to_string();
            let salt = b"kdf-salt-async";
            let info = b"kdf-info-async";
            let seal = HybridSeal::new();
            type Kdf = HkdfSha256;

            // 2. Encryption with KDF
            let encrypted = seal
                .encrypt::<TestDek>(pk_wrapped, kek_id.clone())
                .with_aad(aad)
                .with_kdf(
                    Kdf::default(),
                    Some(salt),
                    Some(info),
                    <TestDek as SymmetricCipher>::KEY_SIZE as u32,
                )
                .to_vec::<TestKem>(plaintext)?;

            // 3. Async Decryption
            let mut decryptor = seal
                .decrypt()
                .async_reader(Cursor::new(&encrypted))
                .await?
                .with_aad(aad)
                .with_typed_key::<TestKem, TestDek>(sk.clone())
                .await?;

            let mut decrypted = Vec::new();
            decryptor.read_to_end(&mut decrypted).await?;
            assert_eq!(
                plaintext,
                decrypted.as_slice(),
                "Async streaming KDF mode failed"
            );

            Ok(())
        }

        #[tokio::test]
        async fn test_xof_async_roundtrip() -> crate::Result<()> {
            // 1. Setup
            let (pk, sk) = TestKem::generate_keypair()?;
            let pk_wrapped = AsymmetricPublicKey::new(pk.to_bytes());
            let plaintext = get_test_data();
            let aad = b"test-aad-for-xof-async-roundtrip";
            let kek_id = "test-xof-kek-id-async".to_string();
            let salt = b"xof-salt-async";
            let info = b"xof-info-async";
            let seal = HybridSeal::new();
            type Xof = Shake256;

            // 2. Encryption with XOF
            let encrypted = seal
                .encrypt::<TestDek>(pk_wrapped, kek_id.clone())
                .with_aad(aad)
                .with_xof(
                    Xof::default(),
                    Some(salt),
                    Some(info),
                    <TestDek as SymmetricCipher>::KEY_SIZE as u32,
                )
                .to_vec::<TestKem>(plaintext)?;

            // 3. Async Decryption
            let mut decryptor = seal
                .decrypt()
                .async_reader(Cursor::new(&encrypted))
                .await?
                .with_aad(aad)
                .with_typed_key::<TestKem, TestDek>(sk.clone())
                .await?;

            let mut decrypted = Vec::new();
            decryptor.read_to_end(&mut decrypted).await?;
            assert_eq!(
                plaintext,
                decrypted.as_slice(),
                "Async streaming XOF mode failed"
            );

            Ok(())
        }

        #[tokio::test]
        async fn test_async_signed_aad_tampering_fails() -> crate::Result<()> {
            let (enc_pk, enc_sk) = TestKem::generate_keypair()?;
            let enc_pk_wrapped = AsymmetricPublicKey::new(enc_pk.to_bytes());
            let (sig_pk, sig_sk) = TestSigner::generate_keypair()?;
            let sig_sk_wrapped = AsymmetricPrivateKey::new(sig_sk.to_bytes());
            let sig_pk_bytes = sig_pk.to_bytes();
            let verification_key = SignaturePublicKey::new(sig_pk_bytes);

            let signer_key_id = "test-signer-key-async".to_string();
            let plaintext = get_test_data();
            let aad = b"test-signed-aad-async";
            let kek_id = "test-signed-aad-kek-async".to_string();
            let seal = HybridSeal::new();

            // Encrypt
            let mut encrypted = Vec::new();
            let mut encryptor = seal
                .encrypt::<TestDek>(enc_pk_wrapped, kek_id)
                .with_aad(aad)
                .with_signer::<TestSigner>(sig_sk_wrapped, signer_key_id)
                .into_async_writer::<TestKem, _>(&mut encrypted)
                .await?;
            encryptor.write_all(plaintext).await?;
            encryptor.shutdown().await?;

            // Successful roundtrip
            let mut decryptor = seal
                .decrypt()
                .async_reader(Cursor::new(&encrypted))
                .await?
                .with_aad(aad)
                .with_verification_key(verification_key.clone())?
                .with_typed_key::<TestKem, TestDek>(enc_sk.clone())
                .await?;
            let mut decrypted_ok = Vec::new();
            decryptor.read_to_end(&mut decrypted_ok).await?;
            assert_eq!(decrypted_ok, plaintext);

            // Fails with wrong AAD
            let res = seal
                .decrypt()
                .async_reader(Cursor::new(&encrypted))
                .await?
                .with_aad(b"wrong-aad")
                .with_verification_key(verification_key)?
                .with_typed_key::<TestKem, TestDek>(enc_sk.clone())
                .await;
            assert!(res.is_err());

            Ok(())
        }
    }
}
