//! High-level API for hybrid encryption.
//!
//! This module provides a unified and user-friendly interface for hybrid encryption,
//! combining asymmetric (public-key) and symmetric cryptography to offer scalable
//! and secure data protection. It is the recommended entry point for most users.
//!
//! ## Workflow
//!
//! The typical hybrid encryption workflow involves two main components:
//! 1.  **Key Encapsulation Mechanism (KEM)**: An asymmetric algorithm (e.g., RSA, Kyber)
//!     used by the sender to securely transfer a randomly generated symmetric key
//!     to the recipient using their public key. This part is computationally
//!     expensive and is only used for the key exchange, not for the bulk data.
//! 2.  **Data Encapsulation Mechanism (DEM)**: A symmetric algorithm (e.g., AES-GCM, XChaCha20-Poly1305)
//!     that uses the randomly generated key (from the KEM step) to encrypt the
//!     actual plaintext data. This part is very fast and suitable for large amounts of data.
//!
//! This library abstracts away the complexities of this process, providing a
//! simple, fluent API.
//!
//! ## Execution Modes
//!
//! The API supports multiple execution modes to cater to different use cases:
//! - **In-Memory (Ordinary)**: The entire encryption/decryption process happens in memory.
//!   Suitable for small to medium-sized data.
//!   - Encrypt: `to_vec()`
//!   - Decrypt: `slice()` -> `with_key()`
//! - **In-Memory (Parallel)**: A parallelized version of the in-memory mode, offering
//!   better performance for multi-core systems, especially for larger data chunks
//!   that still fit in memory.
//!   - Encrypt: `to_vec_parallel()`
//!   - Decrypt: `slice_parallel()` -> `with_key()`
//! - **Streaming**: For very large files or data streams that should not be fully
//!   loaded into memory. This mode processes data in chunks.
//!   - Encrypt: `into_writer()`
//!   - Decrypt: `reader()` -> `with_key()`
//! - **Asynchronous Streaming**: A non-blocking version of the streaming mode,
//!   designed for use with async runtimes like Tokio.
//!   - Encrypt: `into_async_writer()`
//!   - Decrypt: `async_reader()` -> `with_key()`
//!
//! ## Advanced Features
//!
//! The `HybridEncryptionOptions` struct provides access to advanced features:
//! - **Associated Data (AAD)**: Authenticate contextual metadata alongside the ciphertext.
//! - **Digital Signatures**: Sign the encryption header to prove the sender's identity.
//! - **Key Derivation (KDF/XOF)**: Instead of a random DEM key, derive it from the
//!   shared secret generated by the KEM. This is useful for protocol compatibility
//!   and specific security requirements.
//!
//! # Example
//!
//! ``` ignore
//! use seal_crypto::schemes::{
//!     asymmetric::traditional::rsa::Rsa2048,
//!     hash::Sha256,
//!     symmetric::aes_gcm::Aes256Gcm,
//! };
//! use seal_flow::prelude::*;
//!
//! // 1. Define algorithms
//! let kem = AsymmetricAlgorithmEnum::Rsa2048_Sha256;
//! let dem = SymmetricAlgorithmEnum::Aes256Gcm;
//!
//! // 2. Setup keys
//! let (pk, sk) = Rsa2048::<Sha256>::generate_keypair().unwrap();
//! let pk_wrapped = AsymmetricPublicKey::new(pk.to_bytes());
//! let sk_wrapped = AsymmetricPrivateKey::new(sk.to_bytes());
//! let kek_id = "my-key-id".to_string();
//!
//! // 3. Encrypt
//! let seal = HybridSeal::new();
//! let plaintext = b"secret message";
//! let ciphertext = seal.encrypt(pk_wrapped, kek_id)
//!     .execute_with(kem, dem)
//!     .to_vec(plaintext)
//!     .unwrap();
//!
//! // 4. Decrypt
//! let pending = seal.decrypt().slice(&ciphertext).unwrap();
//! let decrypted = pending.with_key(sk_wrapped).unwrap();
//!
//! assert_eq!(plaintext, &decrypted[..]);
//! ```
//!
//! 混合加密的高级 API。
//!
//! 该模块为混合加密提供了一个统一且用户友好的界面，
//! 结合了非对称（公钥）和对称密码学，以提供可扩展且安全的数据保护。
//! 这是推荐给大多数用户的入口点。
//!
//! ## 工作流程
//!
//! 典型的混合加密工作流程涉及两个主要部分：
//! 1.  **密钥封装机制 (KEM)**：发送方使用非对称算法（例如 RSA、Kyber）
//!     通过接收方的公钥将随机生成的对称密钥安全地传输给接收方。
//!     这部分计算成本较高，仅用于密钥交换，不用于批量数据。
//! 2.  **数据封装机制 (DEM)**：使用（来自 KEM 步骤的）随机生成的密钥
//!     来加密实际明文数据的对称算法（例如 AES-GCM、XChaCha20-Poly1305）。
//!     这部分速度非常快，适用于大量数据。
//!
//! 该库抽象了此过程的复杂性，提供了一个简单、流畅的 API。
//!
//! ## 执行模式
//!
//! API 支持多种执行模式，以满足不同的用例：
//! - **内存中（普通）**：整个加密/解密过程在内存中进行。
//!   适用于中小型数据。
//!   - 加密: `to_vec()`
//!   - 解密: `slice()` -> `with_key()`
//! - **内存中（并行）**：内存模式的并行化版本，为多核系统提供更好的性能，
//!   特别是对于仍然可以容纳在内存中的较大数据块。
//!   - 加密: `to_vec_parallel()`
//!   - 解密: `slice_parallel()` -> `with_key()`
//! - **流式**：适用于不应完全加载到内存中的非常大的文件或数据流。
//!   此模式以块为单位处理数据。
//!   - 加密: `into_writer()`
//!   - 解密: `reader()` -> `with_key()`
//! - **异步流式**：流式模式的非阻塞版本，设计用于与 Tokio 等异步运行时一起使用。
//!   - 加密: `into_async_writer()`
//!   - 解密: `async_reader()` -> `with_key()`
//!
//! ## 高级功能
//!
//! `HybridEncryptionOptions` 结构提供了对高级功能的访问：
//! - **关联数据 (AAD)**：与密文一起验证上下文元数据。
//! - **数字签名**：对加密标头进行签名以证明发件人的身份。
//! - **密钥派生 (KDF/XOF)**：从 KEM 生成的共享秘密派生 DEM 密钥，而不是使用随机密钥。
//!   这对于协议兼容性和特定的安全要求非常有用。
//!
//! # 示例
//!
//! ``` ignore
//! use seal_crypto::schemes::{
//!     asymmetric::traditional::rsa::Rsa2048,
//!     hash::Sha256,
//!     symmetric::aes_gcm::Aes256Gcm,
//! };
//! use seal_flow::prelude::*;
//!
//! // 1. 定义算法
//! let kem = AsymmetricAlgorithmEnum::Rsa2048_Sha256;
//! let dem = SymmetricAlgorithmEnum::Aes256Gcm;
//!
//! // 2. 设置密钥
//! let (pk, sk) = Rsa2048::<Sha256>::generate_keypair().unwrap();
//! let pk_wrapped = AsymmetricPublicKey::new(pk.to_bytes());
//! let sk_wrapped = AsymmetricPrivateKey::new(sk.to_bytes());
//! let kek_id = "my-key-id".to_string();
//!
//! // 3. 加密
//! let seal = HybridSeal::new();
//! let plaintext = b"secret message";
//! let ciphertext = seal.encrypt(pk_wrapped, kek_id)
//!     .execute_with(kem, dem)
//!     .to_vec(plaintext)
//!     .unwrap();
//!
//! // 4. 解密
//! let pending = seal.decrypt().slice(&ciphertext).unwrap();
//! let decrypted = pending.with_key(sk_wrapped).unwrap();
//!
//! assert_eq!(plaintext, &decrypted[..]);
//! ```
use crate::common::algorithms::{KdfKeyAlgorithm, SignatureAlgorithm, XofAlgorithm};
use crate::common::config::ArcConfig;
use crate::keys::{AsymmetricPrivateKey, TypedAsymmetricPublicKey};
use decryptor::HybridDecryptorBuilder;
use encryptor::{HybridEncryptor, HybridEncryptorBuilder};
use suites::PqcEncryptorBuilder;

pub mod decryptor;
pub mod encryptor;
pub mod suites;

/// Configuration for a digital signature to be applied during encryption.
///
/// This allows the sender to prove their identity by signing the encryption
/// metadata (header). The recipient can then verify this signature using the
/// sender's public key.
///
/// 用于在加密期间应用的数字签名的配置。
///
/// 这允许发件人通过对加密元数据（标头）进行签名来证明其身份。
/// 然后，接收方可以使用发件人的公钥验证此签名。
pub struct SignerOptions {
    /// The private key used for signing.
    ///
    /// 用于签名的私钥。
    pub key: AsymmetricPrivateKey,
    /// The ID of the signing key. This ID is stored in the header and is used by
    /// the recipient to look up the corresponding public key for verification.
    ///
    /// 签名密钥的 ID。此 ID 存储在标头中，接收方使用它来查找相应的公钥进行验证。
    pub key_id: String,
    /// The signature algorithm to use.
    ///
    /// 要使用的签名算法。
    pub algorithm: SignatureAlgorithm,
}

/// Options for using a Key Derivation Function (KDF) to generate the Data Encryption Key (DEK).
///
/// Normally, a fresh, random DEK is generated for each encryption.
/// Using a KDF allows you to derive a deterministic DEK from the shared secret
/// produced by the Key Encapsulation Mechanism (KEM). This can be necessary for
/// compatibility with certain cryptographic protocols (e.g., HPKE).
///
/// 用于使用密钥派生函数 (KDF) 生成数据加密密钥 (DEK) 的选项。
///
/// 通常，每次加密都会生成一个新的随机 DEK。
/// 使用 KDF 允许您从密钥封装机制 (KEM) 生成的共享秘密中派生出确定性的 DEK。
/// 这对于与某些加密协议（例如 HPKE）的兼容性可能是必需的。
pub struct KdfOptions {
    /// The KDF algorithm to use (e.g., HKDF-SHA256).
    ///
    /// 要使用的 KDF 算法（例如 HKDF-SHA256）。
    pub algorithm: KdfKeyAlgorithm,
    /// An optional salt value, highly recommended for security.
    ///
    /// 可选的盐值，强烈建议为了安全而使用。
    pub salt: Option<Vec<u8>>,
    /// Optional context-specific information, used to bind the derived key to a
    /// specific purpose.
    ///
    /// 可选的特定于上下文的信息，用于将派生密钥绑定到特定目的。
    pub info: Option<Vec<u8>>,
    /// The desired length of the derived DEK in bytes. This must match the
    /// key length required by the chosen symmetric algorithm.
    ///
    /// 派生 DEK 的所需长度（以字节为单位）。这必须与所选对称算法要求的密钥长度相匹配。
    pub output_len: u32,
}

/// Options for using an Extendable-Output Function (XOF) to generate the DEK.
///
/// A XOF is similar to a KDF but can produce an output of arbitrary length.
/// It's a flexible way to derive keys or other security material.
///
/// 用于使用可扩展输出函数 (XOF) 生成 DEK 的选项。
///
/// XOF 类似于 KDF，但可以产生任意长度的输出。
/// 这是派生密钥或其他安全材料的一种灵活方式。
pub struct XofOptions {
    /// The XOF algorithm to use (e.g., SHAKE256).
    ///
    /// 要使用的 XOF 算法（例如 SHAKE256）。
    pub algorithm: XofAlgorithm,
    /// An optional salt value.
    ///
    /// 可选的盐值。
    pub salt: Option<Vec<u8>>,
    /// Optional context-specific information.
    ///
    /// 可选的特定于上下文的信息。
    pub info: Option<Vec<u8>>,
    /// The desired length of the derived DEK in bytes.
    ///
    /// 派生 DEK 的所需长度（以字节为单位）。
    pub output_len: u32,
}

/// Enum to select between KDF and XOF for key derivation.
///
/// 用于在 KDF 和 XOF 之间选择以进行密钥派生的枚举。
pub enum DerivationOptions {
    /// Use a Key Derivation Function.
    ///
    /// 使用密钥派生函数。
    Kdf(KdfOptions),
    /// Use an Extendable-Output Function.
    ///
    /// 使用可扩展输出函数。
    Xof(XofOptions),
}

/// A builder for configuring advanced options for a hybrid encryption operation.
///
/// This struct uses a builder pattern to let you chain configuration calls.
///
/// 用于配置混合加密操作高级选项的构建器。
///
/// 此结构使用构建器模式，让您可以链式调用配置。
#[derive(Default)]
pub struct HybridEncryptionOptions {
    pub(crate) aad: Option<Vec<u8>>,
    pub(crate) signer: Option<SignerOptions>,
    pub(crate) derivation: Option<DerivationOptions>,
}

impl HybridEncryptionOptions {
    /// Creates a new, default set of options.
    ///
    /// 创建一组新的默认选项。
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the Associated Data (AAD) for the encryption operation.
    ///
    /// AAD is authenticated along with the ciphertext but is not encrypted.
    /// It's useful for binding the encrypted data to its context (e.g., headers,
    /// version numbers, or identifiers) to prevent semantic or replay attacks.
    /// The same AAD must be provided during decryption for the authentication to succeed.
    ///
    /// 为加密操作设置关联数据 (AAD)。
    ///
    /// AAD 与密文一起进行身份验证，但不会被加密。
    /// 它对于将加密数据与其上下文（例如，标头、版本号或标识符）绑定以防止语义攻击或重放攻击非常有用。
    /// 在解密期间必须提供相同的 AAD，身份验证才能成功。
    pub fn with_aad(mut self, aad: impl Into<Vec<u8>>) -> Self {
        self.aad = Some(aad.into());
        self
    }

    /// Configures the operation to digitally sign the encryption metadata.
    ///
    /// This proves the sender's identity to the recipient. The `key` should be the
    /// sender's private signing key. The `key_id` is included in the header so
    /// the recipient knows which public key to use for verification.
    ///
    /// 配置操作以对加密元数据进行数字签名。
    ///
    /// 这向接收方证明了发件人的身份。`key` 应该是发件人的私有签名密钥。
    /// `key_id` 包含在标头中，以便接收方知道使用哪个公钥进行验证。
    pub fn with_signer(
        mut self,
        key: AsymmetricPrivateKey,
        key_id: String,
        algorithm: SignatureAlgorithm,
    ) -> Self {
        self.signer = Some(SignerOptions {
            key,
            key_id,
            algorithm,
        });
        self
    }

    /// Configures the operation to use a Key Derivation Function (KDF) to create the DEK.
    ///
    /// Instead of generating a random DEK, it will be derived from the KEM's shared secret.
    ///
    /// # Arguments
    /// * `algorithm`: The KDF algorithm to use.
    /// * `salt`: An optional salt. Highly recommended.
    /// * `info`: Optional context-specific information.
    /// * `output_len`: The desired length of the derived key. Must match the chosen
    ///   symmetric cipher's key length.
    ///
    /// 配置操作以使用密钥派生函数 (KDF) 创建 DEK。
    ///
    /// 它将从 KEM 的共享秘密派生，而不是生成随机的 DEK。
    ///
    /// # 参数
    /// * `algorithm`: 要使用的 KDF 算法。
    /// * `salt`: 可选的盐。强烈推荐。
    /// * `info`: 可选的特定于上下文的信息。
    /// * `output_len`: 派生密钥的所需长度。必须与所选对称密码的密钥长度匹配。
    pub fn with_kdf(
        mut self,
        algorithm: KdfKeyAlgorithm,
        salt: Option<Vec<u8>>,
        info: Option<Vec<u8>>,
        output_len: u32,
    ) -> Self {
        self.derivation = Some(DerivationOptions::Kdf(KdfOptions {
            algorithm,
            salt,
            info,
            output_len,
        }));
        self
    }

    /// Configures the operation to use an Extendable-Output Function (XOF) to create the DEK.
    ///
    /// Similar to a KDF, but based on a XOF algorithm like SHAKE256.
    ///
    /// 配置操作以使用可扩展输出函数 (XOF) 创建 DEK。
    ///
    /// 类似于 KDF，但基于像 SHAKE256 这样的 XOF 算法。
    pub fn with_xof(
        mut self,
        algorithm: XofAlgorithm,
        salt: Option<Vec<u8>>,
        info: Option<Vec<u8>>,
        output_len: u32,
    ) -> Self {
        self.derivation = Some(DerivationOptions::Xof(XofOptions {
            algorithm,
            salt,
            info,
            output_len,
        }));
        self
    }
}

/// A factory for creating hybrid encryption and decryption executors.
/// This struct is the main entry point for the high-level hybrid encryption API.
/// It is stateless and can be reused for multiple operations.
///
/// 用于创建混合加密和解密执行器的工厂。
/// 这个结构体是高级混合加密 API 的主要入口点。
/// 它是无状态的，可以重复用于多个操作。
pub struct HybridSeal {
    config: ArcConfig,
}

impl Default for HybridSeal {
    fn default() -> Self {
        Self::new(ArcConfig::default())
    }
}

impl HybridSeal {
    /// Creates a new `HybridSeal` factory.
    ///
    /// 创建一个新的 `HybridSeal` 工厂。
    pub fn new(config: ArcConfig) -> Self {
        Self { config }
    }

    /// Begins a hybrid encryption operation.
    ///
    /// This method sets up the context for encryption. It captures the recipient's
    /// public key (`pk`) and its identifier (`kek_id`). The `kek_id` is stored
    /// in the ciphertext header so the recipient can easily identify which of their
    /// private keys is needed for decryption.
    ///
    /// This returns a `HybridEncryptor` context object. You can then chain calls
    /// to configure advanced options or call an execution method (like `.to_vec()`)
    // to perform the encryption.
    pub fn encrypt_builder(&self) -> HybridEncryptorBuilder {
        HybridEncryptorBuilder::new(self.config.clone())
    }

    /// Begins a hybrid encryption operation with a specified recipient.
    ///
    /// A convenience method that combines builder creation and recipient specification.
    pub fn encrypt(&self, pk: TypedAsymmetricPublicKey, kek_id: String) -> HybridEncryptor {
        HybridEncryptorBuilder::new(self.config.clone()).with_recipient(pk, kek_id)
    }

    /// Begins a hybrid encryption operation using a recommended Post-Quantum Cryptography (PQC) suite.
    ///
    /// This provides a simplified API that uses `Kyber768` for key encapsulation and
    /// `Aes256Gcm` for data encapsulation, a combination recommended for post-quantum security.
    ///
    /// 使用推荐的后量子密码学 (PQC) 套件开始混合加密操作。
    ///
    /// 这提供了一个简化的 API，使用 `Kyber768` 进行密钥封装，
    /// 使用 `Aes256Gcm` 进行数据封装，这是为后量子安全推荐的组合。
    pub fn encrypt_pqc_suite(&self) -> PqcEncryptorBuilder {
        PqcEncryptorBuilder::new(self.config.clone())
    }

    /// Begins a hybrid decryption operation.
    ///
    /// This returns a `HybridDecryptorBuilder`. You can then use this builder to
    /// specify the source of the ciphertext (e.g., `.slice()` or `.reader()`).
    ///
    /// The builder can also be configured with a `KeyProvider` to automate the
    /// key lookup process during decryption.
    ///
    /// 开始一个解密操作。
    ///
    /// 这将返回一个 `HybridDecryptorBuilder`。然后，您可以使用此构建器来指定
    /// 密文的来源（例如 `.slice()` 或 `.reader()`）。
    ///
    /// 该构建器还可以配置一个 `KeyProvider`，以在解密期间自动执行密钥查找过程。
    pub fn decrypt(&self) -> HybridDecryptorBuilder {
        HybridDecryptorBuilder::new(self.config.clone())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::algorithms::asymmetric::AsymmetricAlgorithmWrapper;
    use crate::algorithms::traits::SignatureAlgorithm;
    use crate::common::algorithms::AsymmetricAlgorithm as AsymmetricAlgorithmEnum;
    use crate::common::algorithms::SignatureAlgorithm as SignatureAlgorithmEnum;
    use crate::common::algorithms::SymmetricAlgorithm as SymmetricAlgorithmEnum;
    use crate::seal::traits::*;
    use crate::Error;
    use std::collections::HashMap;
    use std::io::{Cursor, Read, Write};

    #[cfg(feature = "async")]
    const TEST_KEK_ID: &str = "test-kek";

    fn get_test_data() -> &'static [u8] {
        b"This is a reasonably long test message to ensure that we cross chunk boundaries."
    }

    const TEST_DEM: SymmetricAlgorithmEnum = SymmetricAlgorithmEnum::Aes256Gcm;
    const TEST_SIGNER: SignatureAlgorithmEnum = SignatureAlgorithmEnum::Dilithium2;

    fn test_kem() -> AsymmetricAlgorithmWrapper {
        AsymmetricAlgorithmEnum::Rsa2048Sha256.into_asymmetric_wrapper()
    }

    #[test]
    fn test_in_memory_roundtrip() -> crate::Result<()> {
        let (pk, sk) = test_kem().generate_keypair()?.into_keypair();
        let plaintext = get_test_data();
        let kek_id = "test-kek-id".to_string();
        let seal = HybridSeal::new(ArcConfig::default());

        let encrypted = seal
            .encrypt(pk, kek_id.clone())
            .execute_with(TEST_DEM)
            .to_vec(plaintext)?;

        let pending = seal.decrypt().slice(&encrypted)?;
        assert_eq!(pending.kek_id(), Some(kek_id.as_str()));
        let decrypted = pending.with_key_to_vec(&sk)?;

        assert_eq!(plaintext, decrypted.as_slice());
        Ok(())
    }

    #[test]
    fn test_in_memory_parallel_roundtrip() -> crate::Result<()> {
        let (pk, sk) = test_kem().generate_keypair()?.into_keypair();
        let plaintext = get_test_data();
        let kek_id = "test-kek-id-parallel".to_string();
        let seal = HybridSeal::new(ArcConfig::default());

        let encrypted = seal
            .encrypt(pk, kek_id.clone())
            .execute_with(TEST_DEM)
            .to_vec_parallel(plaintext)?;

        let pending = seal.decrypt().slice_parallel(&encrypted)?;
        assert_eq!(pending.kek_id(), Some(kek_id.as_str()));
        let decrypted = pending.with_key_to_vec(&sk)?;

        assert_eq!(plaintext, decrypted.as_slice());
        Ok(())
    }

    #[test]
    fn test_streaming_roundtrip() -> crate::Result<()> {
        let mut key_store = HashMap::new();
        let (pk, sk) = test_kem().generate_keypair()?.into_keypair();
        key_store.insert("test-kek".to_string(), sk.clone());

        let plaintext = get_test_data();
        let seal = HybridSeal::new(ArcConfig::default());

        // Encrypt
        let mut encrypted_data = Vec::new();
        let mut encryptor = seal
            .encrypt(pk, "test-kek".to_string())
            .execute_with(TEST_DEM)
            .into_writer(&mut encrypted_data)
            .unwrap();
        encryptor.write_all(plaintext).unwrap();
        drop(encryptor);

        // Decrypt
        let pending = seal.decrypt().reader(Cursor::new(encrypted_data)).unwrap();
        let kek_id = pending.kek_id().unwrap();
        let decryption_key = key_store.get(kek_id).unwrap();
        let mut decryptor = pending.with_key_to_reader(decryption_key).unwrap();

        let mut decrypted_data = Vec::new();
        decryptor.read_to_end(&mut decrypted_data).unwrap();
        assert_eq!(plaintext.to_vec(), decrypted_data);
        Ok(())
    }

    #[test]
    fn test_parallel_streaming_roundtrip() -> crate::Result<()> {
        let (pk, sk) = test_kem().generate_keypair()?.into_keypair();
        let plaintext = get_test_data();
        let kek_id = "test-kek-id-p-streaming".to_string();
        let seal = HybridSeal::new(ArcConfig::default());

        let mut encrypted = Vec::new();
        seal.encrypt(pk, kek_id.clone())
            .execute_with(TEST_DEM)
            .pipe_parallel(Cursor::new(plaintext), &mut encrypted)?;

        let pending = seal.decrypt().reader_parallel(Cursor::new(&encrypted))?;
        assert_eq!(pending.kek_id(), Some(kek_id.as_str()));

        let mut decrypted = Vec::new();
        pending.with_key_to_writer(&sk, &mut decrypted)?;

        assert_eq!(plaintext, decrypted.as_slice());
        Ok(())
    }

    #[test]
    fn test_aad_roundtrip() -> crate::Result<()> {
        let (pk, sk) = test_kem().generate_keypair()?.into_keypair();
        let plaintext = get_test_data();
        let aad = b"test-associated-data-for-hybrid";
        let kek_id = "aad-kek".to_string();
        let seal = HybridSeal::new(ArcConfig::default());

        // Encrypt with AAD
        let encrypted = seal
            .encrypt(pk, kek_id.clone())
            .with_aad(aad)
            .execute_with(TEST_DEM)
            .to_vec(plaintext)?;

        // Decrypt with correct AAD
        let pending = seal.decrypt().slice(&encrypted)?;
        assert_eq!(pending.kek_id(), Some(kek_id.as_str()));
        let decrypted = pending.with_aad(aad).with_key_to_vec(&sk)?;
        assert_eq!(plaintext, decrypted.as_slice());

        // Decrypt with wrong AAD fails
        let pending_fail = seal.decrypt().slice(&encrypted)?;
        let result = pending_fail.with_aad(b"wrong-aad").with_key_to_vec(&sk);
        assert!(result.is_err());

        // Decrypt with no AAD fails
        let pending_fail2 = seal.decrypt().slice(&encrypted)?;
        let result2 = pending_fail2.with_key_to_vec(&sk);
        assert!(result2.is_err());

        Ok(())
    }

    #[test]
    fn test_signed_aad_tampering_fails() -> crate::Result<()> {
        // 1. Setup keys
        let (enc_pk, enc_sk) = test_kem().generate_keypair()?.into_keypair();
        let (sig_pk, sig_sk) = TEST_SIGNER
            .into_signature_wrapper()
            .generate_keypair()?
            .into_keypair();

        // 2. Setup verification key
        let signer_key_id = "test-signer-key-mem".to_string();

        let plaintext = get_test_data();
        let aad = b"test-signed-aad-memory";
        let kek_id = "test-signed-aad-kek-mem".to_string();
        let seal = HybridSeal::new(ArcConfig::default());

        // 3. Encrypt with signer and AAD
        let encrypted = seal
            .encrypt(enc_pk, kek_id)
            .with_aad(aad)
            .with_signer(sig_sk, signer_key_id.clone())?
            .execute_with(TEST_DEM)
            .to_vec(plaintext)?;

        // 4. Successful roundtrip with correct verifier and AAD
        let decrypted = seal
            .decrypt()
            .slice(&encrypted)?
            .with_aad(aad)
            .with_verification_key(sig_pk.clone())
            .with_key_to_vec(&enc_sk)?;
        assert_eq!(decrypted.as_slice(), plaintext);

        // 5. Fails with wrong AAD
        let res = seal
            .decrypt()
            .slice(&encrypted)?
            .with_aad(b"wrong aad")
            .with_verification_key(sig_pk.clone())
            .with_key_to_vec(&enc_sk);
        assert!(res.is_err(), "Decryption should fail with wrong AAD");
        assert!(matches!(res.err(), Some(Error::Crypto(_))));

        // 6. Fails with no AAD
        let res2 = seal
            .decrypt()
            .slice(&encrypted)?
            .with_verification_key(sig_pk)
            .with_key_to_vec(&enc_sk);
        assert!(res2.is_err(), "Decryption should fail with no AAD");

        Ok(())
    }

    #[test]
    fn test_kdf_roundtrip_all_modes() -> crate::Result<()> {
        // 1. Setup
        let (pk, sk) = test_kem().generate_keypair()?.into_keypair();
        let plaintext = get_test_data();
        let aad = b"test-aad-for-kdf-roundtrip";
        let kek_id = "test-kdf-kek-id".to_string();
        let salt = b"kdf-salt";
        let info = b"kdf-info";
        let seal = HybridSeal::new(ArcConfig::default());

        // 2. Encryption with KDF
        let encrypted = seal
            .encrypt(pk, kek_id.clone())
            .with_aad(aad)
            .with_kdf(
                KdfKeyAlgorithm::HkdfSha256,
                Some(salt.as_ref()),
                Some(info.as_ref()),
            )
            .execute_with(TEST_DEM)
            .to_vec(plaintext)?;

        // 3. Decryption tests for all sync modes

        // Mode 1: In-memory (`slice`)
        let decrypted1 = seal
            .decrypt()
            .slice(&encrypted)?
            .with_aad(aad)
            .with_key_to_vec(&sk)?;
        assert_eq!(
            plaintext,
            decrypted1.as_slice(),
            "In-memory KDF mode failed"
        );

        // Mode 2: In-memory parallel (`slice_parallel`)
        let decrypted2 = seal
            .decrypt()
            .slice_parallel(&encrypted)?
            .with_aad(aad)
            .with_key_to_vec(&sk)?;
        assert_eq!(
            plaintext,
            decrypted2.as_slice(),
            "In-memory parallel KDF mode failed"
        );

        // Mode 3: Streaming (`reader`)
        let pending3 = seal.decrypt().reader(Cursor::new(encrypted.clone()))?;
        let mut decryptor3 = pending3.with_aad(aad).with_key_to_reader(&sk)?;
        let mut decrypted3 = Vec::new();
        decryptor3.read_to_end(&mut decrypted3)?;
        assert_eq!(
            plaintext,
            decrypted3.as_slice(),
            "Streaming KDF mode failed"
        );

        // Mode 4: Parallel Streaming (`reader_parallel` to writer)
        let mut decrypted4 = Vec::new();
        seal.decrypt()
            .reader_parallel(Cursor::new(&encrypted))?
            .with_aad(aad)
            .with_key_to_writer(&sk, &mut decrypted4)?;
        assert_eq!(
            plaintext,
            decrypted4.as_slice(),
            "Parallel streaming KDF mode failed"
        );

        Ok(())
    }

    #[test]
    fn test_xof_roundtrip_all_modes() -> crate::Result<()> {
        // 1. Setup
        let (pk, sk) = test_kem().generate_keypair()?.into_keypair();
        let plaintext = get_test_data();
        let aad = b"test-aad-for-xof-roundtrip";
        let kek_id = "test-xof-kek-id".to_string();
        let salt = b"xof-salt";
        let info = b"xof-info";
        let seal = HybridSeal::new(ArcConfig::default());

        // 2. Encryption with XOF
        let encrypted = seal
            .encrypt(pk, kek_id.clone())
            .with_aad(aad)
            .with_xof(
                XofAlgorithm::Shake256,
                Some(salt.as_ref()),
                Some(info.as_ref()),
            )
            .execute_with(TEST_DEM)
            .to_vec(plaintext)?;

        // 3. Decryption tests for all sync modes

        // Mode 1: In-memory (`slice`)
        let decrypted1 = seal
            .decrypt()
            .slice(&encrypted)?
            .with_aad(aad)
            .with_key_to_vec(&sk)?;
        assert_eq!(
            plaintext,
            decrypted1.as_slice(),
            "In-memory XOF mode failed"
        );

        // Mode 2: In-memory parallel (`slice_parallel`)
        let decrypted2 = seal
            .decrypt()
            .slice_parallel(&encrypted)?
            .with_aad(aad)
            .with_key_to_vec(&sk)?;
        assert_eq!(
            plaintext,
            decrypted2.as_slice(),
            "In-memory parallel XOF mode failed"
        );

        // Mode 3: Streaming (`reader`)
        let pending3 = seal.decrypt().reader(Cursor::new(encrypted.clone()))?;
        let mut decryptor3 = pending3.with_aad(aad).with_key_to_reader(&sk)?;
        let mut decrypted3 = Vec::new();
        decryptor3.read_to_end(&mut decrypted3)?;
        assert_eq!(
            plaintext,
            decrypted3.as_slice(),
            "Streaming XOF mode failed"
        );

        // Mode 4: Parallel Streaming (`reader_parallel` to writer)
        let mut decrypted4 = Vec::new();
        seal.decrypt()
            .reader_parallel(Cursor::new(&encrypted))?
            .with_aad(aad)
            .with_key_to_writer(&sk, &mut decrypted4)?;
        assert_eq!(
            plaintext,
            decrypted4.as_slice(),
            "Parallel streaming XOF mode failed"
        );

        Ok(())
    }

    #[cfg(feature = "async")]
    mod async_tests {
        use super::*;
        use tokio::io::{AsyncReadExt, AsyncWriteExt};

        #[tokio::test]
        async fn test_asynchronous_streaming_roundtrip() -> crate::Result<()> {
            let mut key_store = HashMap::new();
            let (pk, sk) = test_kem().generate_keypair()?.into_keypair();
            key_store.insert(TEST_KEK_ID.to_string(), sk.clone());

            let plaintext = get_test_data();
            let seal = HybridSeal::new(ArcConfig::default());

            // Encrypt
            let mut encrypted_data = Vec::new();
            {
                let mut encryptor = seal
                    .encrypt(pk, TEST_KEK_ID.to_string())
                    .execute_with(TEST_DEM)
                    .into_async_writer(&mut encrypted_data)
                    .await
                    .unwrap();
                encryptor.write_all(plaintext).await.unwrap();
                encryptor.shutdown().await.unwrap();
            }

            // Decrypt
            let pending = seal
                .decrypt()
                .async_reader(Cursor::new(&encrypted_data))
                .await
                .unwrap();
            let kek_id = pending.kek_id().unwrap();
            let decryption_key = key_store.get(kek_id).unwrap();
            let mut decryptor = pending.with_key_to_reader(decryption_key).await.unwrap();

            let mut decrypted_data = Vec::new();
            decryptor.read_to_end(&mut decrypted_data).await.unwrap();
            assert_eq!(plaintext.to_vec(), decrypted_data);

            Ok(())
        }

        #[tokio::test]
        async fn test_kdf_async_roundtrip() -> crate::Result<()> {
            // 1. Setup
            let (pk, sk) = test_kem().generate_keypair()?.into_keypair();
            let plaintext = get_test_data();
            let aad = b"test-aad-for-kdf-async-roundtrip";
            let kek_id = "test-kdf-kek-id-async".to_string();
            let salt = b"kdf-salt-async";
            let info = b"kdf-info-async";
            let seal = HybridSeal::new(ArcConfig::default());

            // 2. Encryption with KDF
            let encrypted = seal
                .encrypt(pk, kek_id.clone())
                .with_aad(aad)
                .with_kdf(
                    KdfKeyAlgorithm::HkdfSha256,
                    Some(salt.as_ref()),
                    Some(info.as_ref()),
                )
                .execute_with(TEST_DEM)
                .to_vec(plaintext)?;

            // 3. Async Decryption
            let mut decryptor = seal
                .decrypt()
                .async_reader(Cursor::new(&encrypted))
                .await?
                .with_aad(aad)
                .with_key_to_reader(&sk)
                .await?;

            let mut decrypted = Vec::new();
            decryptor.read_to_end(&mut decrypted).await?;
            assert_eq!(
                plaintext,
                decrypted.as_slice(),
                "Async streaming KDF mode failed"
            );

            Ok(())
        }

        #[tokio::test]
        async fn test_xof_async_roundtrip() -> crate::Result<()> {
            // 1. Setup
            let (pk, sk) = test_kem().generate_keypair()?.into_keypair();
            let plaintext = get_test_data();
            let aad = b"test-aad-for-xof-async-roundtrip";
            let kek_id = "test-xof-kek-id-async".to_string();
            let salt = b"xof-salt-async";
            let info = b"xof-info-async";
            let seal = HybridSeal::new(ArcConfig::default());

            // 2. Encryption with XOF
            let encrypted = seal
                .encrypt(pk, kek_id)
                .with_aad(aad)
                .with_xof(
                    XofAlgorithm::Shake256,
                    Some(salt.as_ref()),
                    Some(info.as_ref()),
                )
                .execute_with(TEST_DEM)
                .to_vec(plaintext)?;

            // 3. Async Decryption
            let mut decryptor = seal
                .decrypt()
                .async_reader(Cursor::new(&encrypted))
                .await?
                .with_aad(aad)
                .with_key_to_reader(&sk)
                .await?;

            let mut decrypted = Vec::new();
            decryptor.read_to_end(&mut decrypted).await?;
            assert_eq!(
                plaintext,
                decrypted.as_slice(),
                "Async streaming XOF mode failed"
            );

            Ok(())
        }

        #[tokio::test]
        async fn test_async_signed_aad_tampering_fails() -> crate::Result<()> {
            let (enc_pk, enc_sk) = test_kem().generate_keypair()?.into_keypair();
            let (sig_pk, sig_sk) = TEST_SIGNER
                .into_signature_wrapper()
                .generate_keypair()?
                .into_keypair();

            let signer_key_id = "test-signer-key-async".to_string();
            let plaintext = get_test_data();
            let aad = b"test-signed-aad-async";
            let kek_id = "test-signed-aad-kek-async".to_string();
            let seal = HybridSeal::new(ArcConfig::default());

            // Encrypt
            let mut encrypted = Vec::new();
            {
                let mut encryptor = seal
                    .encrypt(enc_pk, kek_id)
                    .with_aad(aad)
                    .with_signer(sig_sk, signer_key_id.clone())?
                    .execute_with(TEST_DEM)
                    .into_async_writer(&mut encrypted)
                    .await?;
                encryptor.write_all(plaintext).await?;
                encryptor.shutdown().await?;
            }

            // Successful roundtrip
            let mut decryptor = seal
                .decrypt()
                .async_reader(Cursor::new(&encrypted))
                .await?
                .with_aad(aad)
                .with_verification_key(sig_pk.clone())
                .with_key_to_reader(&enc_sk)
                .await?;
            let mut decrypted_ok = Vec::new();
            decryptor.read_to_end(&mut decrypted_ok).await?;
            assert_eq!(decrypted_ok, plaintext);

            // Fails with wrong AAD
            let res = seal
                .decrypt()
                .async_reader(Cursor::new(&encrypted))
                .await?
                .with_aad(b"wrong-aad")
                .with_verification_key(sig_pk)
                .with_key_to_reader(&enc_sk)
                .await;
            assert!(res.is_err());

            Ok(())
        }
    }
}
